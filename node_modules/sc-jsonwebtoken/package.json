{
  "_args": [
    [
      {
        "raw": "sc-jsonwebtoken@~7.4.2",
        "scope": null,
        "escapedName": "sc-jsonwebtoken",
        "name": "sc-jsonwebtoken",
        "rawSpec": "~7.4.2",
        "spec": ">=7.4.2 <7.5.0",
        "type": "range"
      },
      "/home/nicolaas/hackathon/node_modules/sc-auth"
    ]
  ],
  "_from": "sc-jsonwebtoken@>=7.4.2 <7.5.0",
  "_id": "sc-jsonwebtoken@7.4.2",
  "_inCache": true,
  "_location": "/sc-jsonwebtoken",
  "_nodeVersion": "7.10.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/sc-jsonwebtoken-7.4.2.tgz_1496066927747_0.21404642169363797"
  },
  "_npmUser": {
    "name": "topcloudsystems",
    "email": "grosjona@yahoo.com.au"
  },
  "_npmVersion": "4.2.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "sc-jsonwebtoken@~7.4.2",
    "scope": null,
    "escapedName": "sc-jsonwebtoken",
    "name": "sc-jsonwebtoken",
    "rawSpec": "~7.4.2",
    "spec": ">=7.4.2 <7.5.0",
    "type": "range"
  },
  "_requiredBy": [
    "/sc-auth"
  ],
  "_resolved": "https://registry.npmjs.org/sc-jsonwebtoken/-/sc-jsonwebtoken-7.4.2.tgz",
  "_shasum": "2a9f67d891e5ae83422108520b8368ae8336c749",
  "_shrinkwrap": null,
  "_spec": "sc-jsonwebtoken@~7.4.2",
  "_where": "/home/nicolaas/hackathon/node_modules/sc-auth",
  "author": {
    "name": "auth0"
  },
  "bugs": {
    "url": "https://github.com/SocketCluster/sc-jsonwebtoken/issues"
  },
  "dependencies": {
    "joi": "^6.10.1",
    "jws": "^3.1.4",
    "lodash.once": "^4.0.0",
    "ms": "^2.0.0",
    "xtend": "^4.0.1"
  },
  "description": "JSON Web Token implementation (symmetric and asymmetric)",
  "devDependencies": {
    "atob": "^1.1.2",
    "chai": "^1.10.0",
    "conventional-changelog": "~1.1.0",
    "mocha": "^2.1.0",
    "nsp": "^2.6.2",
    "sinon": "^1.15.4"
  },
  "directories": {},
  "dist": {
    "shasum": "2a9f67d891e5ae83422108520b8368ae8336c749",
    "tarball": "https://registry.npmjs.org/sc-jsonwebtoken/-/sc-jsonwebtoken-7.4.2.tgz"
  },
  "engines": {
    "node": ">=0.12",
    "npm": ">=1.4.28"
  },
  "gitHead": "7637b430f457a788346cb9e1140c75d9479ce368",
  "homepage": "https://github.com/SocketCluster/sc-jsonwebtoken#readme",
  "keywords": [
    "jwt"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "topcloudsystems",
      "email": "grosjona@yahoo.com.au"
    }
  ],
  "name": "sc-jsonwebtoken",
  "optionalDependencies": {},
  "readme": "# sc-jsonwebtoken\r\n\r\n[![Build Status](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken)[![Dependency Status](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken)\r\n\r\n\r\nAn implementation of [JSON Web Tokens](https://tools.ietf.org/html/rfc7519).\r\n\r\nThis was developed against `draft-ietf-oauth-json-web-token-08`. It makes use of [node-jws](https://github.com/brianloveswords/node-jws)\r\n\r\n# Install\r\n\r\n```bash\r\n$ npm install sc-jsonwebtoken\r\n```\r\n\r\n# Usage\r\n\r\n### jwt.sign(payload, secretOrPrivateKey, [options, callback])\r\n\r\n(Asynchronous) If a callback is supplied, callback is called with the `err` or the JWT.\r\n\r\n(Synchronous) Returns the JsonWebToken as string\r\n\r\n`payload` could be an object literal, buffer or string. *Please note that* `exp` is only set if the payload is an object literal.\r\n\r\n`secretOrPrivateKey` is a string, buffer, or object containing either the secret for HMAC algorithms or the PEM\r\nencoded private key for RSA and ECDSA. In case of a private key with passphrase an object `{ key, passphrase }` can be used (based on [crypto documentation](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format)), in this case be sure you pass the `algorithm` option.\r\n\r\n`options`:\r\n\r\n* `algorithm` (default: `HS256`)\r\n* `expiresIn`: expressed in seconds or a string describing a time span [zeit/ms](https://github.com/zeit/ms). Eg: `60`, `\"2 days\"`, `\"10h\"`, `\"7d\"`\r\n* `notBefore`: expressed in seconds or a string describing a time span [zeit/ms](https://github.com/zeit/ms). Eg: `60`, `\"2 days\"`, `\"10h\"`, `\"7d\"`\r\n* `audience`\r\n* `issuer`\r\n* `jwtid`\r\n* `subject`\r\n* `noTimestamp`\r\n* `header`\r\n\r\nIf `payload` is not a buffer or a string, it will be coerced into a string using `JSON.stringify`.\r\n\r\nThere are no default values for `expiresIn`, `notBefore`, `audience`, `subject`, `issuer`. These claims can also be provided in the payload directly with `exp`, `nbf`, `aud`, `sub` and `iss` respectively, but you can't include in both places.\r\n\r\nRemember that `exp`, `nbf` and `iat` are **NumericDate**, see related [Token Expiration (exp claim)](#token-expiration-exp-claim)\r\n\r\n\r\nThe header can be customized via the `option.header` object.\r\n\r\nGenerated jwts will include an `iat` (issued at) claim by default unless `noTimestamp` is specified. If `iat` is inserted in the payload, it will be used instead of the real timestamp for calculating other things like `exp` given a timespan in `options.expiresIn`.\r\n\r\nExample\r\n\r\n```js\r\n// sign with default (HMAC SHA256)\r\nvar jwt = require('sc-jsonwebtoken');\r\nvar token = jwt.sign({ foo: 'bar' }, 'shhhhh');\r\n//backdate a jwt 30 seconds\r\nvar older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');\r\n\r\n// sign with RSA SHA256\r\nvar cert = fs.readFileSync('private.key');  // get private key\r\nvar token = jwt.sign({ foo: 'bar' }, cert, { algorithm: 'RS256'});\r\n\r\n// sign asynchronously\r\njwt.sign({ foo: 'bar' }, cert, { algorithm: 'RS256' }, function(err, token) {\r\n  console.log(token);\r\n});\r\n```\r\n\r\n#### Token Expiration (exp claim)\r\n\r\nThe standard for JWT defines an `exp` claim for expiration. The expiration is represented as a **NumericDate**:\r\n\r\n> A JSON numeric value representing the number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time, ignoring leap seconds.  This is equivalent to the IEEE Std 1003.1, 2013 Edition [POSIX.1] definition \"Seconds Since the Epoch\", in which each day is accounted for by exactly 86400 seconds, other than that non-integer values can be represented.  See RFC 3339 [RFC3339] for details regarding date/times in general and UTC in particular.\r\n\r\nThis means that the `exp` field should contain the number of seconds since the epoch.\r\n\r\nSigning a token with 1 hour of expiration:\r\n\r\n```javascript\r\njwt.sign({\r\n  exp: Math.floor(Date.now() / 1000) + (60 * 60),\r\n  data: 'foobar'\r\n}, 'secret');\r\n```\r\n\r\nAnother way to generate a token like this with this library is:\r\n\r\n```javascript\r\njwt.sign({\r\n  data: 'foobar'\r\n}, 'secret', { expiresIn: 60 * 60 });\r\n\r\n//or even better:\r\n\r\njwt.sign({\r\n  data: 'foobar'\r\n}, 'secret', { expiresIn: '1h' });\r\n```\r\n\r\n### jwt.verify(token, secretOrPublicKey, [options, callback])\r\n\r\n(Asynchronous) If a callback is supplied, function acts asynchronously. Callback is passed the decoded payload if the signature and optional expiration, audience, or issuer are valid. If not, it will be passed the error.\r\n\r\n(Synchronous) If a callback is not supplied, function acts synchronously. Returns the payload decoded if the signature (and, optionally, expiration, audience, issuer) are valid. If not, it will throw the error.\r\n\r\n`token` is the JsonWebToken string\r\n\r\n`secretOrPublicKey` is a string or buffer containing either the secret for HMAC algorithms, or the PEM\r\nencoded public key for RSA and ECDSA.\r\n\r\n`options`\r\n\r\n* `algorithms`: List of strings with the names of the allowed algorithms. For instance, `[\"HS256\", \"HS384\"]`.\r\n* `audience`: if you want to check audience (`aud`), provide a value here\r\n* `issuer` (optional): string or array of strings of valid values for the `iss` field.\r\n* `ignoreExpiration`: if `true` do not validate the expiration of the token.\r\n* `ignoreNotBefore`...\r\n* `subject`: if you want to check subject (`sub`), provide a value here\r\n* `clockTolerance`: number of seconds to tolerate when checking the `nbf` and `exp` claims, to deal with small clock differences among different servers\r\n* `maxAge`: the maximum allowed age for tokens to still be valid. Currently it is expressed in milliseconds or a string describing a time span [zeit/ms](https://github.com/zeit/ms). Eg: `1000`, `\"2 days\"`, `\"10h\"`, `\"7d\"`. **We advise against using milliseconds precision, though, since JWTs can only contain seconds. The maximum precision might be reduced to seconds in the future.**\r\n* `clockTimestamp`: the time in seconds that should be used as the current time for all necessary comparisons (also against `maxAge`, so our advise is to avoid using `clockTimestamp` and a `maxAge` in milliseconds together)\r\n\r\n\r\n```js\r\n// verify a token symmetric - synchronous\r\nvar decoded = jwt.verify(token, 'shhhhh');\r\nconsole.log(decoded.foo) // bar\r\n\r\n// verify a token symmetric\r\njwt.verify(token, 'shhhhh', function(err, decoded) {\r\n  console.log(decoded.foo) // bar\r\n});\r\n\r\n// invalid token - synchronous\r\ntry {\r\n  var decoded = jwt.verify(token, 'wrong-secret');\r\n} catch(err) {\r\n  // err\r\n}\r\n\r\n// invalid token\r\njwt.verify(token, 'wrong-secret', function(err, decoded) {\r\n  // err\r\n  // decoded undefined\r\n});\r\n\r\n// verify a token asymmetric\r\nvar cert = fs.readFileSync('public.pem');  // get public key\r\njwt.verify(token, cert, function(err, decoded) {\r\n  console.log(decoded.foo) // bar\r\n});\r\n\r\n// verify audience\r\nvar cert = fs.readFileSync('public.pem');  // get public key\r\njwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {\r\n  // if audience mismatch, err == invalid audience\r\n});\r\n\r\n// verify issuer\r\nvar cert = fs.readFileSync('public.pem');  // get public key\r\njwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {\r\n  // if issuer mismatch, err == invalid issuer\r\n});\r\n\r\n// verify jwt id\r\nvar cert = fs.readFileSync('public.pem');  // get public key\r\njwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {\r\n  // if jwt id mismatch, err == invalid jwt id\r\n});\r\n\r\n// verify subject\r\nvar cert = fs.readFileSync('public.pem');  // get public key\r\njwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {\r\n  // if subject mismatch, err == invalid subject\r\n});\r\n\r\n// alg mismatch\r\nvar cert = fs.readFileSync('public.pem'); // get public key\r\njwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {\r\n  // if token alg != RS256,  err == invalid signature\r\n});\r\n\r\n```\r\n\r\n### jwt.decode(token [, options])\r\n\r\n(Synchronous) Returns the decoded payload without verifying if the signature is valid.\r\n\r\n__Warning:__ This will __not__ verify whether the signature is valid. You should __not__ use this for untrusted messages. You most likely want to use `jwt.verify` instead.\r\n\r\n`token` is the JsonWebToken string\r\n\r\n`options`:\r\n\r\n* `json`: force JSON.parse on the payload even if the header doesn't contain `\"typ\":\"JWT\"`.\r\n* `complete`: return an object with the decoded payload and header.\r\n\r\nExample\r\n\r\n```js\r\n// get the decoded payload ignoring signature, no secretOrPrivateKey needed\r\nvar decoded = jwt.decode(token);\r\n\r\n// get the decoded payload and header\r\nvar decoded = jwt.decode(token, {complete: true});\r\nconsole.log(decoded.header);\r\nconsole.log(decoded.payload)\r\n```\r\n\r\n## Errors & Codes\r\nPossible thrown errors during verification.\r\nError is the first argument of the verification callback.\r\n\r\n### TokenExpiredError\r\n\r\nThrown error if the token is expired.\r\n\r\nError object:\r\n\r\n* name: 'TokenExpiredError'\r\n* message: 'jwt expired'\r\n* expiredAt: [ExpDate]\r\n\r\n```js\r\njwt.verify(token, 'shhhhh', function(err, decoded) {\r\n  if (err) {\r\n    /*\r\n      err = {\r\n        name: 'TokenExpiredError',\r\n        message: 'jwt expired',\r\n        expiredAt: 1408621000\r\n      }\r\n    */\r\n  }\r\n});\r\n```\r\n\r\n### JsonWebTokenError\r\nError object:\r\n\r\n* name: 'JsonWebTokenError'\r\n* message:\r\n  * 'jwt malformed'\r\n  * 'jwt signature is required'\r\n  * 'invalid signature'\r\n  * 'jwt audience invalid. expected: [OPTIONS AUDIENCE]'\r\n  * 'jwt issuer invalid. expected: [OPTIONS ISSUER]'\r\n  * 'jwt id invalid. expected: [OPTIONS JWT ID]'\r\n  * 'jwt subject invalid. expected: [OPTIONS SUBJECT]'\r\n\r\n```js\r\njwt.verify(token, 'shhhhh', function(err, decoded) {\r\n  if (err) {\r\n    /*\r\n      err = {\r\n        name: 'JsonWebTokenError',\r\n        message: 'jwt malformed'\r\n      }\r\n    */\r\n  }\r\n});\r\n```\r\n\r\n## Algorithms supported\r\n\r\nArray of supported algorithms. The following algorithms are currently supported.\r\n\r\nalg Parameter Value | Digital Signature or MAC Algorithm\r\n----------------|----------------------------\r\nHS256 | HMAC using SHA-256 hash algorithm\r\nHS384 | HMAC using SHA-384 hash algorithm\r\nHS512 | HMAC using SHA-512 hash algorithm\r\nRS256 | RSASSA using SHA-256 hash algorithm\r\nRS384 | RSASSA using SHA-384 hash algorithm\r\nRS512 | RSASSA using SHA-512 hash algorithm\r\nES256 | ECDSA using P-256 curve and SHA-256 hash algorithm\r\nES384 | ECDSA using P-384 curve and SHA-384 hash algorithm\r\nES512 | ECDSA using P-521 curve and SHA-512 hash algorithm\r\nnone | No digital signature or MAC value included\r\n\r\n# TODO\r\n\r\n* X.509 certificate chain is not checked\r\n\r\n## Issue Reporting\r\n\r\nIf you have found a bug or if you have a feature request, please report them at this repository issues section. Please do not report security vulnerabilities on the public GitHub issue tracker. The [Responsible Disclosure Program](https://auth0.com/whitehat) details the procedure for disclosing security issues.\r\n\r\n## Author\r\n\r\n[Auth0](https://auth0.com)\r\n\r\n## License\r\n\r\nThis project is licensed under the MIT license. See the [LICENSE](LICENSE) file for more info.\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/SocketCluster/sc-jsonwebtoken.git"
  },
  "scripts": {
    "test": "mocha --require test/util/fakeDate && nsp check"
  },
  "version": "7.4.2"
}
